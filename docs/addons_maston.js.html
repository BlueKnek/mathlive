<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"><title>addons/maston.js - MathLive Docs</title><meta name="description" content="Beautifully typeset math made easy"><meta name="keywords" content="latex, tex, math, typesetting, documentation, docs">

    <meta name="viewport" content="width=device-width, initial-scale=1">


    
        <link rel="stylesheet" href="http://mathlive.io/sprint15/mathlive/mathlive.core.css" type="text/css"><link rel="stylesheet" href="http://mathlive.io/sprint15/mathlive/mathlive.css" type="text/css">
    


    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700|Source+Sans+Pro:400,400i,700,900" rel="stylesheet">
    <style>pre.prettyprint{background: #35434e;}</style>
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow-night.css">

    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="styles/custom.css">
</head>
<body>


<div class="forkme"><a href="https://github.com/arnog/mathlive"><img style="position: absolute; top: 0; right: 0; border: 0; z-index:1;" src="https://camo.githubusercontent.com/52760788cde945287fbb584134c4cbc2bc36f904/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f77686974655f6666666666662e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png"></a></div>


<section role="navigation">
    <input type="checkbox" id="nav-trigger" class="nav-trigger" />
    <label for="nav-trigger" class="navicon-button x">
        <div class="navicon"></div>
    </label>

    <label for="nav-trigger" class="overlay"></label>

    <nav id="nav">
        <h3 class="group-title home"><a href="index.html">MathLive Docs</a></h3><input class="search" placeholder="Search" type="text"><div class="list"><h3 class="group-title">Tutorials</h3><ul><li><a href="tutorial-CONTRIBUTOR_GUIDE.html">Contributor Guide</a><ul></ul></li><li><a href="tutorial-MASTON.html">MASTON</a><ul></ul></li><li><a href="tutorial-USAGE_GUIDE.html">Usage Guide</a><ul><li><a href="tutorial-EXAMPLES.html">Examples</a></li><li><a href="tutorial-COMMANDS_REFERENCE.html">Commands Reference</a></li></ul></li></ul><h3 class="group-title">Modules</h3><ul><li class="private"><a href="module-color.html" class="className">color</a><ul class='methods private'><li data-type='method' class='private'><a href="module-color.html#.stringToColor" class="methodName">stringToColor</a></li></ul></li><li class="private"><a href="module-definitions.html" class="className">definitions</a><ul class='methods private'><li data-type='method' class='private'><a href="module-definitions.html#.defineEnvironment" class="methodName">defineEnvironment</a></li><li data-type='method' class='private'><a href="module-definitions.html#.defineFunction" class="methodName">defineFunction</a></li><li data-type='method' class='private'><a href="module-definitions.html#.defineSymbol" class="methodName">defineSymbol</a></li><li data-type='method' class='private'><a href="module-definitions.html#.defineSymbolRange" class="methodName">defineSymbolRange</a></li><li data-type='method' class='private'><a href="module-definitions.html#.defineSymbols" class="methodName">defineSymbols</a></li><li data-type='method' class='private'><a href="module-definitions.html#.frequency" class="methodName">frequency</a></li><li data-type='method' class='private'><a href="module-definitions.html#.getInfo" class="methodName">getInfo</a></li><li data-type='method' class='private'><a href="module-definitions.html#.matchCodepoint" class="methodName">matchCodepoint</a></li><li data-type='method' class='private'><a href="module-definitions.html#.matchFunction" class="methodName">matchFunction</a></li><li data-type='method' class='private'><a href="module-definitions.html#.parseParamTemplateArgument" class="methodName">parseParamTemplateArgument</a></li><li data-type='method' class='private'><a href="module-definitions.html#.suggest" class="methodName">suggest</a></li></ul></li><li class="private"><a href="module-delimiters.html" class="className">delimiters</a><ul class='methods private'><li data-type='method' class='private'><a href="module-delimiters.html#.makeCustomSizedDelim" class="methodName">makeCustomSizedDelim</a></li><li data-type='method' class='private'><a href="module-delimiters.html#.makeInner" class="methodName">makeInner</a></li><li data-type='method' class='private'><a href="module-delimiters.html#.makeLargeDelim" class="methodName">makeLargeDelim</a></li><li data-type='method' class='private'><a href="module-delimiters.html#.makeLeftRightDelim" class="methodName">makeLeftRightDelim</a></li><li data-type='method' class='private'><a href="module-delimiters.html#.makeNullFence" class="methodName">makeNullFence</a></li><li data-type='method' class='private'><a href="module-delimiters.html#.makeSizedDelim" class="methodName">makeSizedDelim</a></li><li data-type='method' class='private'><a href="module-delimiters.html#.makeSmallDelim" class="methodName">makeSmallDelim</a></li><li data-type='method' class='private'><a href="module-delimiters.html#.makeStackedDelim" class="methodName">makeStackedDelim</a></li><li data-type='method' class='private'><a href="module-delimiters.html#.traverseSequence" class="methodName">traverseSequence</a></li></ul></li><li class="private"><a href="module-editor_editableMathlist.html" class="className">editor/editableMathlist</a><ul class='methods private'><li data-type='method' class='private'><a href="module-editor_editableMathlist.html#~atomContains" class="methodName">atomContains</a></li></ul></li><li class="private"><a href="module-editor_keyboard.html" class="className">editor/keyboard</a><ul class='methods private'><li data-type='method' class='private'><a href="module-editor_keyboard.html#.delegateKeyboardEvents" class="methodName">delegateKeyboardEvents</a></li><li data-type='method' class='private'><a href="module-editor_keyboard.html#.keyboardEventToString" class="methodName">keyboardEventToString</a></li></ul></li><li class="private"><a href="module-editor_mathfield.html" class="className">editor/mathfield</a><ul class='methods private'><li data-type='method' class='private'><a href="module-editor_mathfield.html#nearestElementFromPoint" class="methodName">nearestElementFromPoint</a></li></ul></li><li class="private"><a href="module-editor_mathpath.html" class="className">editor/mathpath</a><ul class='methods private'><li data-type='method' class='private'><a href="module-editor_mathpath.html#.pathCommonAncestor" class="methodName">pathCommonAncestor</a></li><li data-type='method' class='private'><a href="module-editor_mathpath.html#.pathDistance" class="methodName">pathDistance</a></li><li data-type='method' class='private'><a href="module-editor_mathpath.html#.pathFromString" class="methodName">pathFromString</a></li><li data-type='method' class='private'><a href="module-editor_mathpath.html#.pathToString" class="methodName">pathToString</a></li></ul></li><li class="private"><a href="module-editor_shortcuts.html" class="className">editor/shortcuts</a><ul class='methods private'><li data-type='method' class='private'><a href="module-editor_shortcuts.html#.matchEndOf" class="methodName">matchEndOf</a></li><li data-type='method' class='private'><a href="module-editor_shortcuts.html#.matchKeystroke" class="methodName">matchKeystroke</a></li><li data-type='method' class='private'><a href="module-editor_shortcuts.html#.platform" class="methodName">platform</a></li><li data-type='method' class='private'><a href="module-editor_shortcuts.html#.stringify" class="methodName">stringify</a></li></ul></li><li class="private"><a href="module-fontMetrics.html" class="className">fontMetrics</a><ul class='methods private'><li data-type='method' class='private'><a href="module-fontMetrics.html#.getCharacterMetrics" class="methodName">getCharacterMetrics</a></li></ul></li><li class="private"><a href="module-lexer.html" class="className">lexer</a><ul class='methods private'><li data-type='method' class='private'><a href="module-lexer.html#.tokenize" class="methodName">tokenize</a></li></ul></li><li class="private"><a href="module-mathAtom.html" class="className">mathAtom</a><ul class='methods private'><li data-type='method' class='private'><a href="module-mathAtom.html#.decompose" class="methodName">decompose</a></li><li data-type='method' class='private'><a href="module-mathAtom.html#.getFontName" class="methodName">getFontName</a></li><li data-type='method' class='private'><a href="module-mathAtom.html#.makeColGap" class="methodName">makeColGap</a></li><li data-type='method' class='private'><a href="module-mathAtom.html#.makeColOfRepeatingElements" class="methodName">makeColOfRepeatingElements</a></li><li data-type='method' class='private'><a href="module-mathAtom.html#.makeStack" class="methodName">makeStack</a></li></ul></li><li><a href="module-mathlive.html" class="className">mathlive</a><ul class='methods'><li data-type='method'><a href="module-mathlive.html#latexToAST" class="methodName">latexToAST</a></li><li data-type='method'><a href="module-mathlive.html#latexToMarkup" class="methodName">latexToMarkup</a></li><li data-type='method'><a href="module-mathlive.html#latexToMathML" class="methodName">latexToMathML</a></li><li data-type='method'><a href="module-mathlive.html#latexToSpeakableText" class="methodName">latexToSpeakableText</a></li><li data-type='method'><a href="module-mathlive.html#makeMathField" class="methodName">makeMathField</a></li><li data-type='method'><a href="module-mathlive.html#renderMathInDocument" class="methodName">renderMathInDocument</a></li><li data-type='method'><a href="module-mathlive.html#renderMathInElement" class="methodName">renderMathInElement</a></li><li data-type='method'><a href="module-mathlive.html#revertToOriginalContent" class="methodName">revertToOriginalContent</a></li><li data-type='method'><a href="module-mathlive.html#revertToOriginalContent" class="methodName">revertToOriginalContent</a></li></ul></li><li class="private"><a href="module-mathstyle.html" class="className">mathstyle</a><ul class='methods private'><li data-type='method' class='private'><a href="module-mathstyle.html#.toMathstyle" class="methodName">toMathstyle</a></li></ul></li><li class="private"><a href="module-span.html" class="className">span</a><ul class='methods private'><li data-type='method' class='private'><a href="module-span.html#.coalesce" class="methodName">coalesce</a></li><li data-type='method' class='private'><a href="module-span.html#.makeFontSizer" class="methodName">makeFontSizer</a></li><li data-type='method' class='private'><a href="module-span.html#.makeHlist" class="methodName">makeHlist</a></li><li data-type='method' class='private'><a href="module-span.html#.makeSpan" class="methodName">makeSpan</a></li><li data-type='method' class='private'><a href="module-span.html#.makeSpanOfType" class="methodName">makeSpanOfType</a></li><li data-type='method' class='private'><a href="module-span.html#.makeSymbol" class="methodName">makeSymbol</a></li><li data-type='method' class='private'><a href="module-span.html#.makeVlist" class="methodName">makeVlist</a></li><li data-type='method' class='private'><a href="module-span.html#.toString" class="methodName">toString</a></li></ul></li></ul><h3 class="group-title">Classes</h3><ul><li class="private"><a href="Context.html" class="className">Context</a><ul class='methods private'><li data-type='method' class='private'><a href="Context.html#clone" class="methodName">clone</a></li><li data-type='method' class='private'><a href="Context.html#cloneWith" class="methodName">cloneWith</a></li><li data-type='method' class='private'><a href="Context.html#getBackgroundColor" class="methodName">getBackgroundColor</a></li><li data-type='method' class='private'><a href="Context.html#getColor" class="methodName">getColor</a></li><li data-type='method' class='private'><a href="Context.html#setMathstyle" class="methodName">setMathstyle</a></li><li data-type='method' class='private'><a href="Context.html#withMathstyle" class="methodName">withMathstyle</a></li></ul></li><li><a href="EditableMathlist.html" class="className">EditableMathlist</a><ul class='methods'><li data-type='method'><a href="EditableMathlist.html#addColumnAfter_" class="methodName">addColumnAfter_</a></li><li data-type='method'><a href="EditableMathlist.html#addColumnBefore_" class="methodName">addColumnBefore_</a></li><li data-type='method'><a href="EditableMathlist.html#addRowAfter_" class="methodName">addRowAfter_</a></li><li data-type='method'><a href="EditableMathlist.html#addRowBefore_" class="methodName">addRowBefore_</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#ancestor" class="methodName">ancestor</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#anchor" class="methodName">anchor</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#commandOffsets" class="methodName">commandOffsets</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#commitCommandStringBeforeInsertionPoint" class="methodName">commitCommandStringBeforeInsertionPoint</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#contains" class="methodName">contains</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#decorateCommandStringAroundInsertionPoint" class="methodName">decorateCommandStringAroundInsertionPoint</a></li><li data-type='method'><a href="EditableMathlist.html#delete" class="methodName">delete</a></li><li data-type='method'><a href="EditableMathlist.html#delete_" class="methodName">delete_</a></li><li data-type='method'><a href="EditableMathlist.html#deleteNextChar_" class="methodName">deleteNextChar_</a></li><li data-type='method'><a href="EditableMathlist.html#deleteNextWord_" class="methodName">deleteNextWord_</a></li><li data-type='method'><a href="EditableMathlist.html#deletePreviousChar_" class="methodName">deletePreviousChar_</a></li><li data-type='method'><a href="EditableMathlist.html#deletePreviousWord_" class="methodName">deletePreviousWord_</a></li><li data-type='method'><a href="EditableMathlist.html#deleteToGroupEnd_" class="methodName">deleteToGroupEnd_</a></li><li data-type='method'><a href="EditableMathlist.html#deleteToGroupStart_" class="methodName">deleteToGroupStart_</a></li><li data-type='method'><a href="EditableMathlist.html#deleteToMathFieldEnd_" class="methodName">deleteToMathFieldEnd_</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#endOffset" class="methodName">endOffset</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#extend" class="methodName">extend</a></li><li data-type='method'><a href="EditableMathlist.html#extendDown_" class="methodName">extendDown_</a></li><li data-type='method'><a href="EditableMathlist.html#extendToGroupEnd_" class="methodName">extendToGroupEnd_</a></li><li data-type='method'><a href="EditableMathlist.html#extendToGroupStart_" class="methodName">extendToGroupStart_</a></li><li data-type='method'><a href="EditableMathlist.html#extendToMathFieldEnd_" class="methodName">extendToMathFieldEnd_</a></li><li data-type='method'><a href="EditableMathlist.html#extendToMathFieldStart_" class="methodName">extendToMathFieldStart_</a></li><li data-type='method'><a href="EditableMathlist.html#extendToNextBoundary_" class="methodName">extendToNextBoundary_</a></li><li data-type='method'><a href="EditableMathlist.html#extendToNextChar_" class="methodName">extendToNextChar_</a></li><li data-type='method'><a href="EditableMathlist.html#extendToNextWord_" class="methodName">extendToNextWord_</a></li><li data-type='method'><a href="EditableMathlist.html#extendToPreviousBoundary_" class="methodName">extendToPreviousBoundary_</a></li><li data-type='method'><a href="EditableMathlist.html#extendToPreviousChar_" class="methodName">extendToPreviousChar_</a></li><li data-type='method'><a href="EditableMathlist.html#extendToPreviousWord_" class="methodName">extendToPreviousWord_</a></li><li data-type='method'><a href="EditableMathlist.html#extendUp_" class="methodName">extendUp_</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#extractCommandStringAroundInsertionPoint" class="methodName">extractCommandStringAroundInsertionPoint</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#extractContents" class="methodName">extractContents</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#extractContentsOrdInGroupBeforeInsertionPoint" class="methodName">extractContentsOrdInGroupBeforeInsertionPoint</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#extractGroupStringBeforeInsertionPoint" class="methodName">extractGroupStringBeforeInsertionPoint</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#filter" class="methodName">filter</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#focus" class="methodName">focus</a></li><li data-type='method'><a href="EditableMathlist.html#insert" class="methodName">insert</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#insertFirstAtom" class="methodName">insertFirstAtom</a></li><li data-type='method'><a href="EditableMathlist.html#isCollapsed" class="methodName">isCollapsed</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#jump" class="methodName">jump</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#leap" class="methodName">leap</a></li><li data-type='method'><a href="EditableMathlist.html#moveAfterParent_" class="methodName">moveAfterParent_</a></li><li data-type='method'><a href="EditableMathlist.html#moveBeforeParent_" class="methodName">moveBeforeParent_</a></li><li data-type='method'><a href="EditableMathlist.html#moveDown_" class="methodName">moveDown_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToGroupEnd_" class="methodName">moveToGroupEnd_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToGroupStart_" class="methodName">moveToGroupStart_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToMathFieldEnd_" class="methodName">moveToMathFieldEnd_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToMathFieldStart_" class="methodName">moveToMathFieldStart_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToNextChar_" class="methodName">moveToNextChar_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToNextPlaceholder_" class="methodName">moveToNextPlaceholder_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToNextWord_" class="methodName">moveToNextWord_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToOpposite_" class="methodName">moveToOpposite_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToPreviousChar_" class="methodName">moveToPreviousChar_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToPreviousPlaceholder_" class="methodName">moveToPreviousPlaceholder_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToPreviousWord_" class="methodName">moveToPreviousWord_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToSubscript_" class="methodName">moveToSubscript_</a></li><li data-type='method'><a href="EditableMathlist.html#moveToSuperscript_" class="methodName">moveToSuperscript_</a></li><li data-type='method'><a href="EditableMathlist.html#moveUp_" class="methodName">moveUp_</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#next" class="methodName">next</a></li><li data-type='method'><a href="EditableMathlist.html#selectAll_" class="methodName">selectAll_</a></li><li data-type='method'><a href="EditableMathlist.html#selectGroup_" class="methodName">selectGroup_</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#setExtent" class="methodName">setExtent</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#setRange" class="methodName">setRange</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#setSelection" class="methodName">setSelection</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#sibling" class="methodName">sibling</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#siblings" class="methodName">siblings</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#skip" class="methodName">skip</a></li><li data-type='method'><a href="EditableMathlist.html#speakAll_" class="methodName">speakAll_</a></li><li data-type='method'><a href="EditableMathlist.html#speakGroup_" class="methodName">speakGroup_</a></li><li data-type='method'><a href="EditableMathlist.html#speakLeftSibling_" class="methodName">speakLeftSibling_</a></li><li data-type='method'><a href="EditableMathlist.html#speakParent_" class="methodName">speakParent_</a></li><li data-type='method'><a href="EditableMathlist.html#speakRightSibling_" class="methodName">speakRightSibling_</a></li><li data-type='method'><a href="EditableMathlist.html#speakSelection_" class="methodName">speakSelection_</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#startOffset" class="methodName">startOffset</a></li><li data-type='method' class='private'><a href="EditableMathlist.html#toString" class="methodName">toString</a></li><li data-type='method'><a href="EditableMathlist.html#transpose_" class="methodName">transpose_</a></li></ul></li><li class="private"><a href="Lexer.html" class="className">Lexer</a><ul class='methods private'><li data-type='method' class='private'><a href="Lexer.html#end" class="methodName">end</a></li><li data-type='method' class='private'><a href="Lexer.html#get" class="methodName">get</a></li><li data-type='method' class='private'><a href="Lexer.html#isWhiteSpace" class="methodName">isWhiteSpace</a></li><li data-type='method' class='private'><a href="Lexer.html#makeToken" class="methodName">makeToken</a></li><li data-type='method' class='private'><a href="Lexer.html#peek" class="methodName">peek</a></li><li data-type='method' class='private'><a href="Lexer.html#scan" class="methodName">scan</a></li></ul></li><li class="private"><a href="MathAtom.html" class="className">MathAtom</a><ul class='methods private'><li data-type='method' class='private'><a href="MathAtom.html#.toSpeakableText" class="methodName">toSpeakableText</a></li><li data-type='method' class='private'><a href="MathAtom.html#bind" class="methodName">bind</a></li><li data-type='method' class='private'><a href="MathAtom.html#decompose" class="methodName">decompose</a></li><li data-type='method' class='private'><a href="MathAtom.html#decomposeGenfrac" class="methodName">decomposeGenfrac</a></li><li data-type='method' class='private'><a href="MathAtom.html#decomposeLeftright" class="methodName">decomposeLeftright</a></li><li data-type='method' class='private'><a href="MathAtom.html#decomposeLine" class="methodName">decomposeLine</a></li><li data-type='method' class='private'><a href="MathAtom.html#decomposeRule" class="methodName">decomposeRule</a></li><li data-type='method' class='private'><a href="MathAtom.html#filter" class="methodName">filter</a></li><li data-type='method' class='private'><a href="MathAtom.html#makeSpan" class="methodName">makeSpan</a></li></ul></li><li><a href="MathField.html" class="className">MathField</a><ul class='methods'><li data-type='method' class='private'><a href="MathField.html#_getCaretPosition" class="methodName">_getCaretPosition</a></li><li data-type='method' class='private'><a href="MathField.html#_onKeystroke" class="methodName">_onKeystroke</a></li><li data-type='method' class='private'><a href="MathField.html#complete_" class="methodName">complete_</a></li><li data-type='method'><a href="MathField.html#config" class="methodName">config</a></li><li data-type='method'><a href="MathField.html#el" class="methodName">el</a></li><li data-type='method' class='private'><a href="MathField.html#enterCommandMode_" class="methodName">enterCommandMode_</a></li><li data-type='method'><a href="MathField.html#insert" class="methodName">insert</a></li><li data-type='method'><a href="MathField.html#keystroke" class="methodName">keystroke</a></li><li data-type='method'><a href="MathField.html#latex" class="methodName">latex</a></li><li data-type='method'><a href="MathField.html#perform" class="methodName">perform</a></li><li data-type='method'><a href="MathField.html#perform" class="methodName">perform</a></li><li data-type='method' class='private'><a href="MathField.html#render" class="methodName">render</a></li><li data-type='method'><a href="MathField.html#revertToOriginalContent" class="methodName">revertToOriginalContent</a></li><li data-type='method'><a href="MathField.html#selectedText" class="methodName">selectedText</a></li><li data-type='method'><a href="MathField.html#selectionAtEnd" class="methodName">selectionAtEnd</a></li><li data-type='method'><a href="MathField.html#selectionAtStart" class="methodName">selectionAtStart</a></li><li data-type='method'><a href="MathField.html#selectionDepth" class="methodName">selectionDepth</a></li><li data-type='method'><a href="MathField.html#selectionIsCollapsed" class="methodName">selectionIsCollapsed</a></li><li data-type='method'><a href="MathField.html#text" class="methodName">text</a></li><li data-type='method'><a href="MathField.html#typedText" class="methodName">typedText</a></li></ul></li><li class="private"><a href="module-mathstyle.Mathstyle.html" class="className">Mathstyle</a></li><li class="private"><a href="Parser.html" class="className">Parser</a><ul class='methods private'><li data-type='method' class='private'><a href="Parser.html#end" class="methodName">end</a></li><li data-type='method' class='private'><a href="Parser.html#hasLiteral" class="methodName">hasLiteral</a></li><li data-type='method' class='private'><a href="Parser.html#hasLiteralPattern" class="methodName">hasLiteralPattern</a></li><li data-type='method' class='private'><a href="Parser.html#hasToken" class="methodName">hasToken</a></li><li data-type='method' class='private'><a href="Parser.html#lastMathAtom" class="methodName">lastMathAtom</a></li><li data-type='method' class='private'><a href="Parser.html#parseAtom" class="methodName">parseAtom</a></li><li data-type='method' class='private'><a href="Parser.html#parseKeyword" class="methodName">parseKeyword</a></li><li data-type='method' class='private'><a href="Parser.html#parseLimits" class="methodName">parseLimits</a></li><li data-type='method' class='private'><a href="Parser.html#parseSupSub" class="methodName">parseSupSub</a></li><li data-type='method' class='private'><a href="Parser.html#parseToken" class="methodName">parseToken</a></li><li data-type='method' class='private'><a href="Parser.html#scanArg" class="methodName">scanArg</a></li><li data-type='method' class='private'><a href="Parser.html#scanColor" class="methodName">scanColor</a></li><li data-type='method' class='private'><a href="Parser.html#scanDelim" class="methodName">scanDelim</a></li><li data-type='method' class='private'><a href="Parser.html#scanDimen" class="methodName">scanDimen</a></li><li data-type='method' class='private'><a href="Parser.html#scanEnvironment" class="methodName">scanEnvironment</a></li><li data-type='method' class='private'><a href="Parser.html#scanGroup" class="methodName">scanGroup</a></li><li data-type='method' class='private'><a href="Parser.html#scanImplicitGroup" class="methodName">scanImplicitGroup</a></li><li data-type='method' class='private'><a href="Parser.html#scanLeftRight" class="methodName">scanLeftRight</a></li><li data-type='method' class='private'><a href="Parser.html#scanModeSet" class="methodName">scanModeSet</a></li><li data-type='method' class='private'><a href="Parser.html#scanModeShift" class="methodName">scanModeShift</a></li><li data-type='method' class='private'><a href="Parser.html#scanNumber" class="methodName">scanNumber</a></li><li data-type='method' class='private'><a href="Parser.html#scanString" class="methodName">scanString</a></li><li data-type='method' class='private'><a href="Parser.html#scanToken" class="methodName">scanToken</a></li></ul></li><li class="private"><a href="Span.html" class="className">Span</a></li><li class="private"><a href="Token.html" class="className">Token</a></li><li class="private"><a href="UndoManager.html" class="className">UndoManager</a><ul class='methods private'><li data-type='method' class='private'><a href="UndoManager.html#canRedo" class="methodName">canRedo</a></li><li data-type='method' class='private'><a href="UndoManager.html#canUndo" class="methodName">canUndo</a></li><li data-type='method' class='private'><a href="UndoManager.html#redo" class="methodName">redo</a></li><li data-type='method' class='private'><a href="UndoManager.html#snapshot" class="methodName">snapshot</a></li><li data-type='method' class='private'><a href="UndoManager.html#undo" class="methodName">undo</a></li></ul></li></ul><div class="checkbox"><input id="toggle-private" type="checkbox" onclick="
if (!document.getElementById('toggle-private').checked) {
document.documentElement.classList.add('no-private')
writeCookie('symbol-access', 'no-private')
} else {
document.documentElement.classList.remove('no-private')
writeCookie('symbol-access', 'private')
}
"><label for="toggle-private">Include Private Symbols</label></div></div>
        <footer role="contentInfo">
            Made with <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a>. 
            
        </footer>
    </nav>
</section>

<main id="main">
    
        <h1 class="page-title">addons/maston.js</h1>
    

    



    
    <section class="source">
        <article>
            <pre class="prettyprint source linenums">
            
            <code>define(['mathlive/core/definitions', 'mathlive/core/mathAtom'],
    function(Definitions, MathAtom) {

        /**
 * Return the operator precedence of the atom
 * or -1 if not an operator
 * @param {*} atom 
 * @return {number}
 */
function opPrec(atom) {
    if (!atom) return -1;
    return Definitions.getPrecedence(
        Definitions.getCanonicalName(atom.latex || atom.value));
}

const RIGHT_DELIM = {
    '(':    ')',
    '{':    '}',
    '[':    ']',
    '|':    '|',
    '\\lbrace': '\\rbrace',
    '\\langle': '\\rangle',
    '\\lfloor': '\\rfloor',
    '\\lceil':  '\\rceil',
    '\\vert':   '\\vert',
    '\\lvert':  '\\rvert',
    '\\Vert':   '\\Vert',
    '\\lVert':  '\\rVert',
    '\\lbrack': '\\rbrack',
    '\\ulcorner':   '\\urcorner',
    '\\llcorner':   '\\lrcorner',
    '\\lgroup': '\\rgroup',
    '\\lmoustache': '\\rmoustache'
}

const DELIM_FUNCTION = {
    '\\lfloor\\rfloor': 'floor',
    '\\lceil\\rceil': 'ceil',
    '\\vert\\vert': 'abs',
    '\\lvert\\rvert': 'abs',
    '||': 'abs',
    '\\Vert\\Vert': 'norm',
    '\\lVert\\rVert': 'norm',
    '\\ulcorner\\urcorner': 'ucorner',
    '\\llcorner\\lrcorner': 'lcorner',
    '\\langle\\rangle': 'angle',
    '\\lgroup\\rgroup': 'group',
    '\\lmoustache\\rmoustache': 'moustache',
    '\\lbrace\\rbrace': 'brace'
}

const POSTFIX_FUNCTION = {
    '!':    'factorial',
    '\\dag': 'dagger',
    '\\dagger': 'dagger',
    '\\ddager': 'dagger2',
    '\\maltese': 'maltese',
    '\\backprime': 'backprime',
    '\\backdoubleprime': 'backprime2',
    '\\prime':  'prime',
    '\\doubleprime': 'prime2',
    '\\$': '$',
    '\\%': '%',
    '\\_': '_',
    '\\degree': 'degree'
}

/**
 * 
 * @param {Object} expr -- Abstract Syntax Tree object
 * @return {string} -- A string, the symbol, or undefined
 */
function asSymbol(expr) {
    let result = expr;
    if (typeof result !== 'string') {
        result = expr !== undefined ? expr.sym : undefined;
    }
    if (result) {
        const latex = Definitions.getLatexForSymbol(result);
        result = latex || result;
    }
    return result;
}



/**
 * 
 * @param {Object} num -- Abstract Syntax Tree object
 * @return {number} -- A Javascript number, the value of the AST or NaN
 */
function asMachineNumber(num) {
    let result = undefined;
    if (num !== undefined) {
        if (num.num !== undefined) {
            if (num.num.toString().match(/^[+-]?[0-9]*[.]?[0-9]*[eE]?[+-]?[0-9]?$/)) {
                result = parseFloat(num.num);
            }
        } else if (typeof num === 'number') {
            result = parseFloat(num);
        }
    }
    return result;
}

function isNumber(expr) {
    return typeof expr === 'number' || 
        (expr !== undefined &amp;&amp; expr.num !== undefined);
}

/**
 * Return true if the current atom is of the specified type and value.
 * @param {Object} expr 
 * @param {string} type 
 * @param {string} value 
 */
function isAtom(expr, type, value) {
    let result = false;
    const atom = expr.atoms[expr.index];
    if (atom &amp;&amp; atom.type === type) {
        if (value === undefined) {
            result = true;
        } else {
            if (type === 'mord' || type === 'mbin' || type === 'mrel' || type === 'mop') {
                result = (atom.latex &amp;&amp; atom.latex.trim() === value) || atom.value === value;
            } else if (type === 'textord') {
                result = atom.latex.trim() === value;
            } else {
                result = atom.value === value;
            }
        }
    }
    return result;
}



/**
 * Parse for a possible sup/sub at the current token location.
 * Handles both sup/sub attached directly to the current atom 
 * as well as "empty" atoms with a sup/sub following the current
 * atom.
 * @param {Object} expr 
 */
function parseSupsub(expr) {
    let atom = expr.atoms[expr.index - 1];

    // Is there a supsub directly on this atom?
    if (!atom || !(atom.superscript || atom.subscript)) {
        atom = null;
    }

    // Is the following atom a subsup atom?
    if (!atom) {
        atom = expr.atoms[expr.index];
        if (isAtom(expr, 'mord', '\u200b') &amp;&amp; (atom.superscript || atom.subscript)) {
            expr.index += 1;
        } else {
            atom = null;
        }
    }

    if (atom) {
        if (typeof expr.ast === 'string') {
            expr.ast = {sym: expr.ast};            
        } else if (typeof expr.ast === 'number') {
            expr.ast = {num: expr.ast};            
        } else if (!expr.ast.group &amp;&amp; !expr.ast.fn &amp;&amp; !expr.ast.sym) {
            expr.ast = {group: expr.ast};
        }
        if (atom.subscript) expr.ast.sub = parse(atom.subscript);
        if (atom.superscript) expr.ast.sup = parse(atom.superscript);
    }

    return expr;
}


/**
 * Parse postfix operators, such as "!" (factorial)
 */
function parsePostfix(expr) {
    const atom = expr.atoms[expr.index];
    const lhs = expr.ast;
    const digraph = parseDigraph(expr);
    if (digraph) {
        expr.ast = {op: digraph.ast, lhs: lhs};
        expr = parseSupsub(expr);
        expr = parsePostfix(expr);
    } else if (atom &amp;&amp; atom.latex &amp;&amp; atom.latex.match(/\^{.*}/)) {
        expr.index += 1;
        // It's a superscript Unicode char (e.g. ⁰¹²³⁴⁵⁶⁷⁸⁹ⁱ⁺⁻⁼...)
        if (typeof expr.ast === 'string') {
            expr.ast = {sym: expr.ast};            
        } else if (typeof expr.ast === 'number') {
            expr.ast = {num: expr.ast};            
        } else if (!expr.ast.group &amp;&amp; !expr.ast.fn &amp;&amp; !expr.ast.sym) {
            expr.ast = {group: expr.ast};
        }
        const sup = atom.latex.match(/\^{(.*)}/)[1];
        const n = parseInt(sup);
        if (!isNaN(n)) {
            expr.ast.sup = n;
        } else {
            expr.ast.sup = sup;
        }

    } else if (atom &amp;&amp; atom.type === 'textord' &amp;&amp; POSTFIX_FUNCTION[atom.latex.trim()]) {
        expr.index += 1;
        expr.ast = {fn: POSTFIX_FUNCTION[atom.latex.trim()], arg: lhs};
        expr = parseSupsub(expr);
        expr = parsePostfix(expr);
    }
    return expr;
}



/**
 * Delimiters can be expressed:
 * - as a matching pair of regular characters: '(a)'
 * - a as 'leftright' expression: '\left(a\right)'
 * - as a matching pair of 'sizeddelim': '\Bigl(a\Bigr)
 * 
 * Note that the '\delim' command is only used for delimiters in the middle
 * of a \left\right pair and not to represent pair-matched delimiters.
 * 
 * This function handles all three cases
 * 
 */ 
 function parseDelim(expr, ldelim, rdelim) {
    expr.index = expr.index || 0;

    if (expr.atoms.length === 0 || expr.index >= expr.atoms.length) {
        expr.ast = undefined;
        return expr;
    }
    
    let atom = expr.atoms[expr.index];

    if (!ldelim) {
        // If we didn't expect a specific delimiter, parse any delimiter
        // and return it as a function application
        let pairedDelim = true;
        if (atom.type === 'mopen') {
            ldelim = atom.latex.trim();
            rdelim = RIGHT_DELIM[ldelim];
        } else if (atom.type === 'sizeddelim') {
            ldelim = atom.delim;
            rdelim = RIGHT_DELIM[ldelim];
        } else if (atom.type === 'leftright') {
            pairedDelim = false;
            ldelim = atom.leftDelim;
            rdelim = atom.rightDelim;
        } else if (atom.type === 'textord') {
            ldelim = atom.latex.trim();
            rdelim = RIGHT_DELIM[ldelim];
        }
        if (ldelim &amp;&amp; rdelim) {
            expr = parseDelim(expr, ldelim, rdelim);
            if (expr) {
                if (pairedDelim) expr.index += 1;
                expr.ast = {
                    fn: DELIM_FUNCTION[ldelim + rdelim] || (ldelim + rdelim),
                    arg: expr.ast};
                return expr;
            }
        }
        return undefined;
    }

    if (atom.type === 'mopen' &amp;&amp; (atom.latex.trim() === ldelim || atom.value === ldelim)) {
        expr.index += 1;    // Skip the open delim
        expr = parseExpression(parsePrimary(expr));
        atom = expr.atoms[expr.index];
        if (atom &amp;&amp; atom.type === 'mclose' &amp;&amp; 
            (atom.latex.trim() === rdelim || atom.value === rdelim)) {
            expr.index += 1;
            expr = parseSupsub(expr);
            expr = parsePostfix(expr);
        } // TODO: else, syntax error?

    } else if (atom.type === 'textord' &amp;&amp; (atom.latex.trim() === ldelim || atom.value === ldelim)) {
            expr.index += 1;    // Skip the open delim
            expr = parseExpression(parsePrimary(expr));
            atom = expr.atoms[expr.index];
            if (atom &amp;&amp; atom.type === 'textord' &amp;&amp; 
                (atom.latex.trim() === rdelim || atom.value === rdelim)) {
                expr.index += 1;
                expr = parseSupsub(expr);
                expr = parsePostfix(expr);
            } // TODO: else, syntax error?
    
    } else if (atom.type === 'sizeddelim' &amp;&amp; atom.delim === ldelim) {
        expr.index += 1;    // Skip the open delim
        expr = parseExpression(parsePrimary(expr));
        atom = expr.atoms[expr.index];
        if (atom &amp;&amp; atom.type === 'sizeddelim' &amp;&amp; atom.delim === rdelim) {
            expr.index += 1;
            expr = parseSupsub(expr);
            expr = parsePostfix(expr);
        } // TODO: else, syntax error?

    } else if (atom.type === 'leftright' &amp;&amp; 
        atom.leftDelim === ldelim &amp;&amp; 
        atom.rightDelim === rdelim) {
        // This atom type includes the content of the parenthetical expression 
        // in its body
        expr.ast = parse(atom.body);
        expr.index += 1;
        expr = parseSupsub(expr);
        expr = parsePostfix(expr);

    } else {
        return undefined;
    }

    return expr;
}


/** 
 * Some symbols are made up of two consecutive characters.
 * Handle them here. Return undefined if not a digraph.
 * TODO: other digraphs:
 * :=
 * ++
 * **
 * =:
 * °C U+2103
 * °F U+2109
 * 
*/
function parseDigraph(expr) {
    expr.index = expr.index || 0;

    if (expr.atoms.length === 0 || expr.index >= expr.atoms.length) {
        return undefined;
    }
    
    if (isAtom(expr, 'textord', '\\nabla')) {
        expr.index += 1;
        if (isAtom(expr, 'mbin', '\\times')) {
            expr.index += 1;
            expr.ast = 'curl';   // divergence
            return expr;
        } else if (isAtom(expr, 'mbin', '\\cdot')) {
            expr.index += 1;
            expr.ast = 'div';  
            return expr;
        }
        expr.index -= 1;
    } else if (isAtom(expr, 'textord', '!')) {
        expr.index += 1;
        if (isAtom(expr, 'textord', '!')) {
            expr.index += 1;
            expr.ast = 'factorial2';
            return expr;
        }
        expr.index -= 1;
    }

    return undefined;
}


function parsePrimary(expr) {

    // &lt;primary> := ('-'|'+) &lt;primary> | &lt;number> | '(' &lt;expression> ')' | &lt;symbol> 

     expr.index = expr.index || 0;
     expr.ast = undefined;

    if (expr.atoms.length === 0 || expr.index >= expr.atoms.length) {
        return expr;
    }
    
    let atom = expr.atoms[expr.index];
    const val = Definitions.getCanonicalName(atom.latex || atom.value);

    const digraph = parseDigraph(expr);
    if (digraph) {
        // expr = parseSupsub(expr);
        const fn = {op: expr.ast};
        fn.lhs = parsePrimary(expr).ast;
        expr.ast = fn;

    } else if (atom.type === 'mbin' &amp;&amp; (val === '-' || val === '+')) {
        // Prefix + or - sign
        expr.index += 1;  // Skip the '+' or '-' symbol
        atom = expr.atoms[expr.index];
        expr = parsePrimary(expr);
        if (atom &amp;&amp; '0123456789.'.indexOf(atom.latex) >= 0) {
            if (expr.ast.num &amp;&amp; typeof expr.ast.num === 'number') {
                expr.ast.num = val === '-' ? -expr.ast.num : expr.ast.num;
            } else if (typeof expr.ast === 'number') {
                expr.ast = val === '-' ? -expr.ast : expr.ast;
            } else {
                expr.ast = {op: val, rhs: expr.ast};
            }
        } else {
            expr.ast = {op: val, rhs: expr.ast};
        }

    } else if ((atom.type === 'mord' &amp;&amp; '0123456789.'.indexOf(atom.latex) >= 0)
         || isAtom(expr, 'mpunct', ',')) {
        // Looks like a number
        let num = '';
        let done = false;
        let pat = '0123456789.eEdD';
        while (expr.index &lt; expr.atoms.length &amp;&amp; !done &amp;&amp; (isAtom(expr, 'spacing') ||
                (
                    (
                        isAtom(expr, 'mord') || 
                        isAtom(expr, 'mpunct', ',') || 
                        isAtom(expr, 'mbin')
                    ) &amp;&amp;
                        pat.indexOf(expr.atoms[expr.index].latex) >= 0
                    )
                )
            ) {
            if (expr.atoms[expr.index].type === 'spacing') {
                expr.index += 1;
            } else {
                let digit = expr.atoms[expr.index].latex;
                if (digit === 'd' || digit === 'D') {
                    digit = 'e';
                    pat = '0123456789.+-'
                } else if (digit === 'e' || digit === 'E') {
                    pat = '0123456789.+-'
                } else if (pat === '0123456789.+-') {
                    pat = '0123456789';
                }
                num += digit === ',' ? '' : digit;
                if (atom.superscript !== undefined || atom.underscript !== undefined) {
                    done = true; 
                } else {
                    expr.index += 1;
                }                
            }
        }
        expr.ast = parseFloat(num);

        // This was a number. Is it followed by a fraction, e.g. 2 1/2
        atom = expr.atoms[expr.index];
        if (atom &amp;&amp; atom.type === 'genfrac' &amp;&amp; 
            (expr.ast.num !== undefined || !isNaN(expr.ast))) {
            // Add an invisible plus, i.e. 2 1/2 = 2 + 1/2
            const lhs = expr.ast;
            expr = parsePrimary(expr);
            expr.ast = {lhs: lhs, op:'+', rhs: expr.ast};
        }   
        expr = parseSupsub(expr);
        expr = parsePostfix(expr);
        
    } else if (atom.type === 'genfrac' || atom.type === 'surd') {
        expr.index += 1;
        expr.ast = atom.toAST();
        expr = parseSupsub(expr);
        expr = parsePostfix(expr);

    } else if (atom.type === 'font') {
        expr.ast = atom.toAST();
        if (expr.ast.sym &amp;&amp; expr.ast.variant === 'normal' &amp;&amp; 
            Definitions.isFunction(expr.ast.sym)) {
            // This is a function (for example used with \\mathrm{foo}
            expr.ast = {fn: expr.ast.sym};
            expr = parseSupsub(expr);

            const fn = expr.ast;
            expr.index += 1;  // Skip the function name
            fn.arg = parsePrimary(expr).ast;
            expr.ast = fn;
            
        } else {
            // It's an identifier of some kind...
            if (atom.superscript === undefined) {
                expr.index += 1;
            }
            expr = parseSupsub(expr);
        }
        expr = parsePostfix(expr);

    } else if (atom.type === 'mord') {
        // A 'mord' but not a number, either an identifier ('x') or a function
        // ('\\Zeta')
        const name = Definitions.getCanonicalName(atom.latex || atom.value);
        if (Definitions.isFunction(name) &amp;&amp; opPrec(atom) &lt; 0) {
            // A function
            expr.ast = {fn: name};
            expr = parseSupsub(expr);

            const fn = expr.ast;
            expr.index += 1;  // Skip the function name
            fn.arg = parsePrimary(expr).ast;
            expr.ast = fn;
        } else {
            // An identifier
            expr.ast = atom.toAST();
            if (atom.superscript === undefined) {
                expr.index += 1;
            }
            expr = parseSupsub(expr);
        }
        expr = parsePostfix(expr);

    } else if (atom.type === 'textord') {
        // Note that 'textord' can also be operators, and are handled as such 
        // in parseExpression()
        if (opPrec(atom) &lt; 0) {
            // This doesn't look like a textord operator
            if (!RIGHT_DELIM[atom.latex.trim()]) {
                // Not an operator, not a fence, it's a symbol or a function
                const name = Definitions.getCanonicalName(atom.latex || atom.value);
                if (Definitions.isFunction(name)) {
                    // It's a function
                    expr.ast = {fn: name};
                    expr = parseSupsub(expr);
        
                    const fn = expr.ast;
                    expr.index += 1;  // Skip the function name
                    fn.arg = parsePrimary(expr).ast;
                    expr.ast = fn;
                        
                    expr = parsePostfix(expr);
                            
                } else {
                    // It was a symbol...
                    expr.ast = atom.toAST();
                    if (atom.superscript === undefined) {
                        expr.index += 1;
                    }
                    expr = parseSupsub(expr);
                    expr = parsePostfix(expr);
                }
            }
        }

    } else if (atom.type === 'mop') {
        // Could be a function or an operator.
        const name = Definitions.getCanonicalName(atom.latex || atom.value);
        if (Definitions.isFunction(name) &amp;&amp; opPrec(atom) &lt; 0) {
            expr.index += 1;
            expr.ast = {fn: name};
            expr = parseSupsub(expr);

            if (expr.ast.sup) {
                // There was an exponent with the function. 
                if (expr.ast.sup === -1 || (expr.ast.sup.op === '-' &amp;&amp; expr.ast.sup.rhs === 1)) {
                    // This is the inverse function
                    const INVERSE_FUNCTION = {
                        'sin' : 'arcsin',
                        'cos':  'arccos',
                        'tan':  'arctan',
                        'cot':  'arccot',
                        'sec':  'arcsec',
                        'csc':  'arccsc',
                        'sinh': 'arsinh',
                        'cosh': 'arcosh',
                        'tanh': 'artanh',
                        'csch': 'arcsch',
                        'sech': 'arsech',
                        'coth': 'arcoth'
                    };
                    if (INVERSE_FUNCTION[expr.ast.fn]) {
                        const fn = {fn: INVERSE_FUNCTION[expr.ast.fn]};
                        fn.arg = parsePrimary(expr).ast;
                        expr.ast = fn;
                    } else {
                        const fn = expr.ast;
                        fn.arg = parsePrimary(expr).ast;
                        expr.ast = fn;
                    }
                } else {
                    // Keep the exponent, add the argument
                    const fn = expr.ast;
                    fn.arg = parsePrimary(expr).ast;
                    expr.ast = fn;
                }

            } else {
                const fn = expr.ast;
                fn.arg = parsePrimary(expr).ast;
                expr.ast = fn;
            }
        }
    } else if (atom.type === 'sizing') {
       expr.index += 1;
       return parsePrimary(expr); 
    }


    if (expr.ast === undefined) {
        // Parse either a group of paren, and return their content as the result
        // or a pair of delimiters, and return them as a function applied 
        // to their content, i.e. "|x|" -> {fn: "||", arg: "x"}
        const delim = parseDelim(expr, '(', ')') || parseDelim(expr);
        if (delim) {
            expr = delim;
        } else {
            if (opPrec(atom) &lt; 0) {
                // This is not an operator (if it is, it may be an operator 
                // dealing with an empty lhs. It's possible.
                // Couldn't interpret the expression. Output an error.
                expr.ast = {text: '?'};
                expr.ast.error = 'Unexpected token ' + 
                    "'" + atom.type + "' = " + atom.value + ' = ' + atom.latex;
                expr.index += 1;    // Skip the unexpected token, and attempt to continue
            }
        }
    }

    atom = expr.atoms[expr.index];
    if (atom &amp;&amp; (atom.type === 'mord' || 
            atom.type === 'surd' || 
            atom.type === 'mop' || 
            atom.type === 'mopen' || 
            atom.type === 'sizeddelim' || 
            atom.type === 'leftright')) {
        if (atom.type === 'sizeddelim') {
            for (const d in RIGHT_DELIM) {
                if (atom.delim === RIGHT_DELIM[d]) {
                    // This is (most likely) a closing delim, exit.
                    // There are ambiguous cases, for example |x|y|z|.
                    expr.index += 1;
                    return expr;
                }
            }
        }
        if ((atom.type === 'mord' || atom.type === 'textord' || atom.type === 'mop') &amp;&amp; opPrec(atom) >= 0) {
            // It's actually an operator
            return expr;
        }
        const lhs = expr.ast;
        expr = parsePrimary(expr);
        if ((lhs === 'f' || lhs === 'g') &amp;&amp; expr &amp;&amp; expr.ast) {
            // TODO: need to parse multiple arguments, e.g. f(x, y)
            expr.ast  = {fn: lhs, arg: expr.ast};
        } else if (expr &amp;&amp; expr.ast) {
            // Invisible times, e.g. '2x'
            expr.ast = {lhs: lhs, op:'*', rhs: expr.ast};
        } else {
            expr.ast = lhs;
        }
    }

    return expr;
}

/**
 * Given an atom or an array of atoms, return their MathML representation as 
 * a string.
 * @param {Object} expr An expressions, including expr.atoms, expr.index, 
 * expr.minPrec the minimum precedence that this parser should parse
 * before returning; expr.lhs (optional); expr.ast, the resulting AST.
 * @return {Object} the expr object, updated
 * @private
 */
function parseExpression(expr) {
    expr.minPrec = expr.minPrec || 0;
    expr.index = expr.index || 0;

    if (expr.atoms.length === 0 || expr.index >= expr.atoms.length) {
        return expr;
    }
    
    let atom = expr.atoms[expr.index];

    let lhs = expr.ast;
    expr.lhs = undefined;
    while (atom &amp;&amp; (atom.type === 'delim' || opPrec(atom) >= expr.minPrec)) {
        const opName = parseDigraph(expr) || Definitions.getCanonicalName(atom.latex);
        atom = expr.atoms[expr.index];  // parseDigraph may have avanced to the next token.
        const opPrecedence = opPrec(atom);
        expr.index += 1;    // advance to next token
        let rhs = parsePrimary(expr).ast;
        atom = expr.atoms[expr.index];
        while (atom &amp;&amp; (atom.type === 'delim' || opPrec(atom) >= opPrecedence)) {
            expr.lhs = rhs;
            expr.minPrec = opPrec(atom);
            rhs = parseExpression(expr).ast;
            atom = expr.atoms[expr.index];
        }
        // Handle in-line fractions, i.e. "1/4" instead of \genfrac.
        // This can happen when text is pasted directly in...
        if (opName === '/') {
            const p = asMachineNumber(lhs);
            const q = asMachineNumber(rhs);
            if (!isNaN(p) &amp;&amp; Number.isInteger(p) &amp;&amp; !isNaN(q) &amp;&amp; Number.isInteger(q)) {
                lhs = {num: p.toString() + '/' + q.toString()};
            } else {
                lhs = {lhs: lhs, op: '/', rhs: rhs}
            }
        
        } else {
            lhs = {lhs: lhs, op: opName, rhs: rhs}
        }
    }

    expr.ast = lhs;

    return expr;
}



function toString(atoms) {
    let result = '';
    for (const atom of atoms) {
        if (atom.type === 'textord' || atom.type === 'mord') {
            result += atom.value;
        }
    }
    return escapeText(result);
}


/**
 * Return a string escaped as necessary to comply with the JSON format
 * @param {string} s 
 * @return {string}
 */
function escapeText(s) {
    return s
    .replace(/[\\]/g, '\\\\')
    .replace(/["]/g, '\\"')
    .replace(/[\b]/g, "\\b")
    .replace(/[\f]/g, "\\f")
    .replace(/[\n]/g, "\\n")
    .replace(/[\r]/g, "\\r")
    .replace(/[\t]/g, "\\t");
}

/**
 * Return an AST representation of a single atom
 * 
 * @return {Object}
 */
MathAtom.MathAtom.prototype.toAST = function() {
    const MATH_VARIANTS = {
        'mathrm':   'normal',
        'mathbb': 'double-struck',
        'mathbf': 'bold',
        'mathcal': 'script',
        'mathfrak': 'fraktur',
        'mathscr': 'script',
        'mathsf': 'sans-serif',
        'mathtt': 'monospace'
    };
    // TODO: See https://www.w3.org/TR/MathML2/chapter6.html#chars.letter-like-tables

    let result = {};
    let sym = '';
    let m;
    let lhs, rhs, p, q;
    const variant = MATH_VARIANTS[this.fontFamily || this.font];

    const command = this.latex ? this.latex.trim() : null;
    switch(this.type) {
        case 'root':
            result.group = parse(this.children);
            break;

        case 'genfrac':
            lhs = parse(this.numer);
            rhs = parse(this.denom);
            p = parseInt(lhs);
            q = parseInt(rhs);
            if (!isNaN(p) &amp;&amp; !isNaN(q)) {
                result.num = p.toString() + '/' + q.toString();
            } else {
                result.lhs = lhs;
                result.op = '/';
                result.rhs = rhs;
            }
            break;

        case 'surd':
            if (this.index) {
                result.fn = 'pow';
                result.arg = [parse(this.body)];
                result.arg[1] = {lhs: 1, op: '/', rhs: parse(this.index)};
            } else {
                result.fn = 'sqrt';
                result.arg = parse(this.body);
            }
            break;

        case 'rule':
            break;

        case 'font':
            if (this.latex === '\\text ') {
                result.text = toString(this.body);
                if (this.toLatex) {
                    result.latex = this.toLatex();
                }
            } else {
                result.sym = toString(this.body);
            }
            break;

        case 'line':
        case 'overlap':
        case 'accent':
            break;

        case 'overunder':
            break;

        case 'mord':
        case 'textord':
            // Check to see if it's a \char command
            m = !command ? undefined : command.match(/[{]?\\char"([0-9abcdefABCDEF]*)[}]?/);
            if (m) {
                sym = String.fromCodePoint(parseInt(m[1], 16));
            } else {
                sym = Definitions.getCanonicalName(command || this.value);
                if (sym.length > 0 &amp;&amp; sym.charAt(0) === '\\') {
                    // This is an identifier with no special handling. 
                    // Use the Unicode value if outside ASCII range
                    if (this.value) {
                        // TODO: consider making this an option?
                        // if (this.value.charCodeAt(0) > 255) {
                        //     sym = '&amp;#x' + ('000000' + 
                        //         this.value.charCodeAt(0).toString(16)).substr(-4) + ';';
                        // } else {
                            sym = this.value.charAt(0);
                        // }
                    }
                }
            }
            if (variant) {
                result.sym = escapeText(sym);
            } else {
                result = escapeText(sym);       // Shortcut: symbol as string
            }
            break;

        // case 'mbin':
        // break;

        // case 'mpunct':
        //     result = '&lt;mo separator="true">' + command + '&lt;/mo>';
        //     break;

        case 'minner':
            break;

        case 'op':
        case 'mop':
            break;

        case 'color':
            break;
        case 'box':
            break;

        case 'enclose':
            // result = '&lt;menclose notation="';
            // for (const notation in this.notation) {
            //     if (this.notation.hasOwnProperty(notation) &amp;&amp; 
            //         this.notation[notation]) {
            //         result += sep + notation;
            //         sep = ' ';
            //     }
            // }
            // result += '">' + toAST(this.body).mathML + '&lt;/menclose>';
            break;

        case 'spacing':
        case 'space':
        case 'sizing':
        case 'mathstyle':
            break;
        default: 
            console.log('Unhandled atom ' + this.type + ' - ' + this.value);
            
    }

    if (variant) {
        result.variant = variant;
    }

    return result;
}

/**
 * 
 * @param {*} atoms an array of atoms
 * @return  {string}
 */
function parse(atoms) {

    return parseExpression(parsePrimary({atoms: atoms})).ast;
}

MathAtom.toAST = function(atoms) {
    return parse(atoms);
}

/**
 * 
 * @param {string} fence -- The fence to validate
 * @param {string} -- Default values, in case no fence is provided
 * @return {string} -- A valid fence
 */
function validateFence(fence, defaultFence) {
    let result = fence || defaultFence;

    // Make sure there are some default values, even if no default fence was 
    // provided.
    // A fence can be up to three characters:
    // - open fence
    // - close fence
    // - middle fence
    // '.' indicate and empty, invisible fence.

    result += '...';

    return result;
}


/**
 * Return a formatted mantissa:
 * 1234567 -> 123 456 7...
 * 1233333 -> 12(3)
 * @param {*} m 
 * @param {*} config 
 */
function formatMantissa(m, config) {
    const originalLength = m.length;
    // The last digit may have been rounded, if it exceeds the precison, 
    // which could throw off the 
    // repeating pattern detection. Ignore it.
    m = m.substr(0, config.precision - 2);

    for (let i = 0; i &lt; m.length - 16; i++) {
        // Offset is the part of the mantissa that is not repeating
        const offset = m.substr(0, i);
        // Try to find a repeating pattern of length j
        for (let j = 0; j &lt; 17; j++) {
            const cycle = m.substr(i, j + 1);
            const times = Math.floor((m.length - offset.length) / cycle.length);
            if (times > 1) {
                if ((offset + cycle.repeat(times + 1)).startsWith(m)) {
                    // We've found a repeating pattern!
                    if (cycle === '0') {
                        return offset.replace(/(\d{3})/g, '$1' + config.groupSeparator);
                    }
                    return offset.replace(/(\d{3})/g, '$1' + config.groupSeparator) +
                        config.beginRepeatingDigits + 
                        cycle.replace(/(\d{3})/g, '$1' + config.groupSeparator) + 
                        config.endRepeatingDigits;
                }
            }
        }
    }
    if (originalLength !== m.length) {
        m += '\\ldots';
    }
    return  m.replace(/(\d{3})/g, '$1' + config.groupSeparator);
}

 /**
 * 
 * @param {Object|number} num -- A number element, or a number or a bignumber or a fraction
 * @return {string} -- A LaTeX representation of the AST
 */
function numberAsLatex(num, config) {
    let result = '';
    if (typeof num === 'string' &amp;&amp; num.indexOf('/') >= 0) {
        result = num;
        // It's a fraction
        const m = num.match(/(\+|-)?(\d*)\/(\d*)/);
        if (m) {
            result = (m[1] || '');
            if (m[3] === '0') {
                result = 0;
            } else if (m[3] === '1') {
                result += m[2];
            } else {
                result += '\\frac{' + m[2] + '}{' + m[3] + '}';
            }
        }

        return result;
    }

    if (typeof config.precision === 'number') {
        if (typeof num === 'number') {
            num = parseFloat(num.toFixed(Math.min(20, config.precision)));
        } else if (typeof num === 'string' &amp;&amp; num.indexOf('/') >= 0) {
            // It's a fraction. We can ignore the precision
        } else {
            let sign = '';
            if (num[0] === '-') {
                sign = '-';
                num = num.substr(1);
            } else if (num[0] === '+') {
                num = num.substr(1);
            }
            if (num.indexOf('.') >= 0) {
                // if (num.length - 1 &lt; config.precision) {
                //     // 
                //     return sign + formatMantissa(num, config);
                // }
                const m = num.match(/(\d*).(\d*)/);
                const base = m[1];
                const mantissa = m[2];
                
                if (base === '0') {
                    let p = 2;  // Index of the first non-zero digit after the decimal
                    while (num[p] === '0' &amp;&amp; p &lt; num.length - 1) {
                        p += 1;
                    }
                    let r = '';
                    if (p &lt;= 6) {
                        r = '0' + config.decimalMarker;
                        r += num.substr(2, p - 2);
                        r += formatMantissa(num.substr(r.length), config);
                    } else {
                        r = num[p];
                        const f = formatMantissa(num.substr(p + 1), config);
                        if (f) {
                            r += config.decimalMarker + f;
                        }
                    }
                    if (num.length - 1 > config.precision &amp;&amp; !r.endsWith('}') &amp;&amp; !r.endsWith('\\ldots')) {
                        r += '\\ldots';
                    }
                    if (p > 6) {
                        r += config.exponentProduct;
                        if (config.exponentMarker) {
                            r += config.exponentMarker + (1 - p).toString();
                        } else {
                            r += '10^{' + (1 - p).toString() + '}';
                        }
                    }
                    num = r;
                } else {
                    num = base.replace(/\B(?=(\d{3})+(?!\d))/g, config.groupSeparator);
                    const f = formatMantissa(mantissa, config);
                    if (f) {
                        num += config.decimalMarker + f;
                        if (num.length - 1 > config.precision &amp;&amp; !num.endsWith('}') &amp;&amp; !num.endsWith('\\ldots')) {
                            num += '\\ldots';
                        }
                    }
                }
            } else if (num.length > config.precision) {
                const len = num.length;
                let r = num[0];
                const f = formatMantissa(num.substr(2), config);
                if (f) {
                    r += config.decimalMarker + f;
                    if (r[r.length - 1] !== '}') {
                        r += '\\ldots';
                    }
                }
                if (r !== '1') {
                    r += config.exponentProduct;
                } else {
                    r = '';
                }
                if (config.exponentMarker) {
                    r += config.exponentMarker + (len - 2).toString();
                } else {
                    r += '10^{' + (len - 2).toString() + '}';
                }
                num = r;
            } else {
                num = num.replace(/\B(?=(\d{3})+(?!\d))/g, config.groupSeparator);
            }
            return sign + num;
        }
    }
    if (config.scientificNotation === 'engineering') {
        // Ensure the exponent is a multiple of 3
        if (num === 0) {
            result = '0';
        } else {
            const y = Math.abs(num);
            let exponent = Math.round(Math.log10(y));
            exponent = exponent - exponent % 3;
            if (y &lt; 1000) exponent = 0;
            let mantissa = y / Math.pow(10, exponent);
            const m = mantissa.toString().match(/^(.*)\.(.*)$/);
            if (m &amp;&amp; m[1] &amp;&amp; m[2]) {
                mantissa = m[1] + config.decimalMarker + m[2];
            }
            if (config.groupSeparator) {
                mantissa = formatMantissa(mantissa.toExponential(), config);
            }
            if (exponent === 0) {
                exponent = '';
            } else if (config.exponentMarker) {
                exponent = config.exponentMarker + exponent;
            } else {
                exponent = config.exponentProduct + ' 10^{' + exponent + '}';
            }
            result = (num &lt; 0 ? '-' : '') + mantissa + exponent;
        }
    } else {
        const valString = typeof num === 'string' ? num : num.toString();
        let m = valString.match(/^(.*)[e|E]([-+]?[0-9]*)$/i);
        let base, exponent, mantissa;
        base = valString;
        mantissa = '';
        if (m &amp;&amp; m[1] &amp;&amp; m[2]) {
            // There is an exponent...
            base = m[1];
            if (config.exponentMarker) {
                exponent = config.exponentMarker + m[2];
            } else {
                exponent = config.exponentProduct + ' 10^{' + m[2] + '}';
            }
        }
        m = base.match(/^(.*)\.(.*)$/);
        if (m &amp;&amp; m[1] &amp;&amp; m[2]) {
            base = m[1];
            mantissa = m[2];
        }
        if (config.groupSeparator) {
            base = base.replace(/\B(?=(\d{3})+(?!\d))/g, config.groupSeparator);
            mantissa = formatMantissa(mantissa, config);
        }
        if (mantissa) mantissa = config.decimalMarker + mantissa;
        result = base + mantissa + (exponent || '');
    }
    return result;
}



 /**
 * 
 * @param {Object} ast -- Abstract Syntax Tree object
 * @return {string} -- A LaTeX representation of the AST
 */
function asLatex(ast, options) {
    const config = Object.assign({
        precision:              14,
        decimalMarker:          '.',
        groupSeparator:         '\\, ',
        product:                '\\cdot ',   // \\times, \\,
        exponentProduct:        '\\cdot ',
        exponentMarker:         '',
        arcSeparator:           '\\,',
        scientificNotation:     'auto', // 'engineering', 'auto', 'on'
        beginRepeatingDigits:   '\\overline{',
        endRepeatingDigits:     '}',
    }, options, config);

    let result = '';

    if (ast === undefined) return '';

    if (ast.latex) {
        // If ast.latex key is present, use it to render the element
        result = ast.latex;

    } else if (ast.num !== undefined &amp;&amp; ast.num.match(/([+-]?[0-9]+)\/([0-9]+)/)) {
        result = numberAsLatex(ast.num, config);
        if (ast.sup) result += '^{' + asLatex(ast.sup, config) + '}';
        if (ast.sub) result += '_{' + asLatex(ast.sub, config) + '}';

    } else if (isNumber(ast)) {
        const val = typeof ast === 'number' ? ast : ast.num;
        if (isNaN(val)) {
            result = '\\mathrm{NaN}';
        } else if (val === -Infinity) {
            result = '-\\infty ';
        } else if (val === Infinity) {
            result = '\\infty ';
        } else {
            result = numberAsLatex(ast.num || ast, config);
        }
        if (ast.sup) result += '^{' + asLatex(ast.sup, config) + '}';
        if (ast.sub) result += '_{' + asLatex(ast.sub, config) + '}';

    } else if (ast.re !== undefined || ast.im !== undefined ) {
        let wrap = false;
        if (Math.abs(ast.im) &lt;= 1e-14 &amp;&amp; Math.abs(ast.re) &lt;= 1e-14) {
            result = '0';
        } else {
            if (ast.re &amp;&amp; Math.abs(ast.re) > 1e-14) {
                result = numberAsLatex(ast.re, config);
            }
            if (Math.abs(ast.im) > 1e-14) {
                const im = asMachineNumber(ast.im); 
                if (Math.abs(ast.re) > 1e-14) {
                    result += im > 0 ? '+' : '';
                    wrap = true;
                }
                result += (Math.abs(im) !== 1 ? 
                    numberAsLatex(ast.im, config) : '') + '\\imaginaryI ';
            }
            if (wrap) {
                const fence = validateFence(ast.fence, '(),');
                result = fence[0] + result + fence[1];
            }
        }
        if (ast.sup) result += '^{' + asLatex(ast.sup, config) + '}';
        if (ast.sub) result += '_{' + asLatex(ast.sub, config) + '}';

    } else if (ast.group) {
        result = asLatex(ast.group);
        if (!isNumber(ast.group) &amp;&amp; !asSymbol(ast.group)) {
            const fence = validateFence(ast.fence, '(),');
            result = fence[0] + result + fence[1];
        }
        if (ast.sup) result += '^{' + asLatex(ast.sup, config) + '}';
        if (ast.sub) result += '_{' + asLatex(ast.sub, config) + '}';

    } else if (ast.fn) {
        if (ast.fn === 'pow' &amp;&amp; Array.isArray(ast.arg) &amp;&amp; ast.arg.length >= 2) {
            result = asLatex(ast.arg[0], config);
            if (!isNumber(ast.arg[0]) &amp;&amp; !asSymbol(ast.arg[0])) {
                const fence = validateFence(ast.fence, '(),');
                result = fence[0] + result + fence[1];
            }
    
            result += '^{' + asLatex(ast.arg[1], config) + '}';
        } else {
            const fn = Definitions.getLatexTemplateForFunction(ast.fn);
            let argstring = '';
            const optionalParen = ast.fn.match(/^(factorial(2)?|(((ar|arc)?(sin|cos|tan|cot|sec|csc)h?)|ln|log|lb))$/);
            if (Array.isArray(ast.arg) || !optionalParen) {
                let sep = '';
                const fence = validateFence(ast.fence, '(),');
                if (fence[0] !== '.') argstring += fence[0];
                if (Array.isArray(ast.arg)) {
                    for (const arg of ast.arg) {
                        argstring += sep + asLatex(arg, config);
                        sep = ', ';
                    }
                } else if (ast.arg) {
                    argstring += asLatex(ast.arg, config);
                }
                if (fence[1] !== '.') argstring += fence[1];
            } else if (ast.arg !== undefined) {
                // The parenthesis may be option...
                if (typeof ast.arg === 'number' || 
                    typeof ast.arg === 'string' ||
                    ast.arg.num !== undefined ||
                    ast.arg.sym !== undefined ||
                    ast.arg.op === '/' ||
                    ast.arg.fn === 'sqrt') {
                    // A simple argument, no need for parentheses
                    argstring = asLatex(ast.arg, config);

                } else {
                    // A complex expression, use parentheses if the arguments 
                    // are the last element of the function template.
                    // For example, for abs()... |%|, parenthesis are not necessary.
                    if (fn[fn.length - 1] === '%') {
                        const fence = validateFence(ast.fence, '(),');
                        argstring += fence[0];
                        argstring += asLatex(ast.arg, config);
                        argstring += fence[1];
                    } else {
                        argstring = asLatex(ast.arg, config);
                    }
                }
            }

            result = fn;
            if (ast.over || ast.sup) {
                result = result.replace('%^','^{' + asLatex(ast.over || ast.sup, config) + '}');
            } else {
                result = result.replace('%^','');
            }
            if (ast.under || ast.sub) {
                result = result.replace('%_','_{' + asLatex(ast.under || ast.sub, config) + '}');
            } else {
                result = result.replace('%_','');
            }

            // Insert the arguments in the function template
            result = result.replace('%', argstring);
        }

    } else if (ast.sym !== undefined || typeof ast === 'string') {
        result = asSymbol(ast);
        // Is it a Unicode value?
        let m = result.match(/^&amp;#x([0-9a-f]+);$/i);
        if (m &amp;&amp; m[1]) {
            result = String.fromCodePoint(parseInt(m[1], 16));
        } else {
            m = result.match(/^&amp;#([0-9]+);$/i);
            if (m &amp;&amp; m[1]) {
                result = String.fromCodePoint(parseInt(m[1]));
            }
        }

        // Is there a variant info attached to it?
        if (ast.variant) {
            const MATH_VARIANTS = {
                'normal':   'mathrm',
                'double-struck': 'mathbb',
                'bold': 'mathbf',
                // 'script': 'mathcal',
                'fraktur': 'mathfrak',
                'script': 'mathscr',
                'sans-serif': 'mathsf',
                'monospace': 'mathtt'
            };
            result = '\\' + MATH_VARIANTS[ast.variant] + 
                '{' + result + '}';
        }
        if (ast.sup) result += '^{' + asLatex(ast.sup, config) + '}';
        if (ast.sub) result += '_{' + asLatex(ast.sub, config) + '}';

    } else if (ast.op) {
        if (ast.op === '/') {
            result = '\\frac{' + asLatex(ast.lhs, config) + '}{' + asLatex(ast.rhs, config) + '}';
            if (ast.sup || ast.sub) {
                result = '(' + result + ')';
                if (ast.sup) result += '^{' + asLatex(ast.sup, config) + '}';
                if (ast.sub) result += '_{' + asLatex(ast.sub, config) + '}';
            }
        } else {
            let lhs, rhs;
            lhs = asLatex(ast.lhs, config);
            if (ast.lhs &amp;&amp; ast.lhs.op &amp;&amp; Definitions.getPrecedence(ast.lhs.op) &lt; Definitions.getPrecedence(ast.op)) {
                lhs = '(' + lhs + ')';
            }
            
            rhs = asLatex(ast.rhs, config);
            if (ast.rhs &amp;&amp; ast.rhs.op &amp;&amp; Definitions.getPrecedence(ast.rhs.op) &lt; Definitions.getPrecedence(ast.op)) {
                rhs = '(' + rhs + ')';
            }

            if (ast.op === '*') {
                result = '%0 ' + config.product + ' %1';
            } else {
                result = Definitions.getLatexTemplateForOperator(ast.op);
            }
            result = result.replace('%^', ast.sup ? '^{' + asLatex(ast.sup, config) + '}' : '');
            result = result.replace('%_', ast.sub ? '_{' + asLatex(ast.sub, config) + '}' : '');
            result = result.replace('%0', lhs).replace('%1', rhs).replace('%', lhs);
        }

    } else if (ast.text) {
        result = '\\text{' + ast.text + '}';

    } else if (ast.array) {
        // TODO
    }

    // If there was an error attached to this node, 
    // display it on a red background
    if (ast.error) {
        result = '\\bbox[#F56165]{' + result + '}';
    }

    return result;
}


// Export the public interface for this module
return { 
    asLatex,
    asMachineNumber,
    isNumber,
    asSymbol,
}


})
</code></pre>
        </article>
    </section>




</main>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="scripts/namis.search.jquery.js"></script>
<script>
    function readCookie(a) {
        var b = document.cookie.match('(^|;)\\s*' + a + '\\s*=\\s*([^;]+)');
        return b ? b.pop() : '';
    }
    function writeCookie(a, v) {
		var date = new Date();
		date.setTime(date.getTime()+(30*24*60*60*1000));
    	document.cookie = a + "=" + v + "; expires=" + date.toUTCString() + "; path=/";
    }

    var cookie = readCookie('symbol-access');
    if (cookie === 'no-private') {
        document.documentElement.classList.add('no-private');
    }
    
   document.getElementById('toggle-private').checked = 
    !document.documentElement.classList.contains('no-private');


    prettyPrint();
    (function($){
        $('#nav').search(['className', 'methodName']);
    })(jQuery);
</script>
<script src="scripts/linenumber.js"></script>


    <script src="http://mathlive.io/sprint15/mathlive/mathlive.js"></script><script>if (MathLive) {MathLive.renderMathInDocument();}</script>


</body>
</html>
